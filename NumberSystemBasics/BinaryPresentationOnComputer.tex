\section{二进制的计算机表示}\label{sec:NumberSystemBasics/BinaryPresentationOnComputer}
    我们需要找到一种可以只用二进制表示各种数，并且直觉上符合基本的四则运算的二进制数的记录方式，才能满足现代的二进制计算机的要求。另外，由于存储空间是有限的，因此我们要考虑的记录方式的长度也是有限的：在计算机的现实中，我们并不存在数学那样的理论上可以无限添加数字长度的简易记录方式（因此，这些记录方式会有一个“能表达的数的范围”的概念，以后我们将称之为“数据范围”。相关的内容将在后续章节中再详细描述，这里暂时忽略）。

    \subsection{二补数}\label{subsec:NumberSystemBasics/BinaryPresentation/TwosComplement}
        在本节中，为了讨论的方便，我们暂不讨论小数（同样，后续的章节会介绍小数的记录方式），只考虑一个 $8$ 位的存储整数的设备（即，必须而且只能使用 $8$ 位二进制来表示，若超过 $8$ 位则将其截断，只保留最右边的 $8$ 位）。

        我们非常容易想到的记录方式是，直接将要记录的数字转成二进制，比如说将 $1$ 表达为 $0000\ 0001$，将 $2$ 表达为 $0000\ 0010$ 等，但是这种表达方式的弊端也非常明显：它无法记录负数。为了记录负数，我们首先要经过一段探索的历程，以取得一种符合期望的记录方式。

        总的来说，我们希望它：
        \begin{enumerate}
            \item 与现有的二进制记录方式尽可能兼容；
            \item 互为相反数的两个数相加结果为 $0$；
            \item 减去一个数，等于加上这个数的相反数；
            \item 表达结果直接相加减，等于相加减结果的表达；
            \item 不断“加 1”之后能走遍一个范围内的全部数，并且在溢出截断之后再次加“回”到某个数的时候，其所表达的数值不变。
        \end{enumerate}

        我们将我们所期望的记录方式分为两部分，一部分是表达正数的规范，另一部分是表达负数的规范，并分别定义：
        \begin{itemize}
            \item 首先，借鉴我们现有的把正负号放在数的最开头的写法，我们任意地定义最左边的一位为符号位，并且任意地定义 $0$ 表示正数，$1$ 表示负数，剩下的位用来表达实际的数。
            \item 然后，我们定义，如果表达的是正数，那么“实际的数”这一节直接采用所欲表达的数的二进制形式。
            \item 剩下的就是如何定义负数的表达了。
        \end{itemize}

        利用最后一条规则，我们可以观察从 $1$ 连续减去两个 1 以到达 $-1$ 的过程，以进行如下的思考：

        二进制 $0000\ 0001$ 减去 $0000\ 0001$ 之后得到了 $0000\ 0000$，再 减去 $0000\ 0001$ 时就会发生“不够减”的情况，这便让我们联想到小学时学减法所学到的方式：可以往“前”去“借 1”。但是对于这个 $0000\ 0000$，“借 1”会往前一直借到开头，我们便虚空补上一个 $1$ 用来借，变成 $1\ 0000\ 0000$，减掉 $0000\ 0001$ 之后，我们就得到了 $1111\ 1111$，看起来是 $-1$ 的某种表示。
        \begin{displayquote}
            由于我们一开始假定了一个 8 位的设备，所以在设备之外的第 9 位上发生的事情其实与设备无关，这个虚空补上的 $1$ 并不会实际影响计算，所以我们可以放心地补上一个虚空的 $1$。
        \end{displayquote}

        我们可以继续这个过程，得到 $-2$ 的表示 $1111\ 1110$，$-3$ 的表示 $1111\ 1101$……，一直到 $-128$ 的表示 $1000\ 0000$。
        \begin{displayquote}
            再减下去就变成 $0111\ 1111$ 了，它以 $0$ 开头，根据前面的期望定义，它是正数 $127$，已经被定义了，我们不能搞出冲突的定义，所以负数的部分到 $1000\ 0000$ 为止。
        \end{displayquote}

        现在，我们有了一个负数的二进制表示的一一对应的方式，然后试图通过观察总结一下它的规律：抛开“负数的记录方式”这个框架的话，对于一个正数 $x$ 而言，它的负数 $-x$ 的二进制表示与 $x$ 的二进制表示相加的结果恰好都是 $1\ 0000\ 0000$，亦即一个负数 $-x$ 的二进制表示是 $1\ 0000\ 0000$ 减去其绝对值的二进制表示的结果。这里的 $1\ 0000\ 0000$ 在数值上恰好是 $2 ^ 8$，而 $8$ 是前文我们指定的设备位数。就此，我们便摸索出了一套能够表达正数与负数的二进制表示方式。

        接下来，我们看看这一套二进制表示方式能否符合前文描述的要求：
        \begin{enumerate}
            \item 与现有的二进制记录方式尽可能兼容：能，正数部分直接使用，负数部分使用 $2$ 的设备位数次方减去去绝对值；
            \item 互为相反数的两个数相加结果为 $0$：能，在 8 位的设备上，相加结果是 $1\ 0000\ 0000$，截断之后是 $0$；
            \item 减去一个数，等于加上这个数的相反数：能，在 8 位设备上，加上一个数的相反数，等于加上 $1\ 0000\ 0000$ 减去这个数的差，由于“加上 $1\ 0000\ 0000$”在 8 位设备上等同于加 $0$，对结果无影响，因此加上一个数的相反数等于减去这个数；
            \item 表达结果直接相加减，等于相加减结果的表达：能，上一条可以将这一条合并成二进制的加法，而二进制的加法符合这一条要求；
            \item 不断“加 1”之后能走遍一个范围内的全部数，并且在溢出截断之后再次加“回”到某个数的时候，其所表达的数值不变：需要额外定义补充，在 $0111\ 1111$ 加 1 时，需要补充一条规则“满 128 减 256”，在 $1111\ 1111$ 加 1 时的行为符合要求。
        \end{enumerate}

        由此，我们得到了一个行为符合预期的可以记录 $-2 ^ k$ 到 $2 ^ k  -1$ 范围内的整数的 $k$ 位二进制记录方式\cite{vonneumann-1993}：
        \begin{enumerate}
            \item 左起第一位为数符，并定义 $0$ 表示正，$1$ 表示负；
            \item 剩下的 $k - 1$ 位为尾数，并定义，当记录正数时，记录数的二进制表示；当记录负数时，记录数加上 $2 ^ k$ 的结果。
        \end{enumerate}

        前面，我们在表达负数 $-a$ 的时候，提及了一个与它对应的数 $2 ^ k - a$。事实上，由于我们已经定义好一个整数二进制记录方式，并且我们已经证明它符合一条定理“减去一个数，等于加上这个数的相反数”，因此这个计算方式其实对正数也适用，因此我们可以将这个数的概念泛化。

        类比于在十进制下我们把 9 结尾的数与 1 补足到整十，由于 $2 ^ k - a$ 恰好能够与 $a$ 补整到 $2 ^ k$，因此我们把 $2 ^ k - a$ 称为 $a$ 的“以 2 为基底的补足数”，简称为二补数（2's Complement）。

    \subsection{一补数}\label{subsec:NumberSystemBasics/BinaryPresentation/OnesComplement}
        前面指定了一种整数的二进制的记录方式，但是整数的二进制的记录方式并非只有一种：从形式的简洁上，我们可以很容易想到另外一种表达：
        \begin{enumerate}
            \item 全部位都用来记录欲表达的数的绝对值；
            \item 如果欲表达的数是负数，那么每一位都取反（即，$1$ 变成 $0$，$0$ 变成 $1$）。
        \end{enumerate}

        我们容易验证，这种表达方式也是符合大部分期望的：
        \begin{enumerate}
            \item 与现有的二进制记录方式尽可能兼容：能，正数部分直接使用，负数部分按位取反；
            \item 互为相反数的两个数相加结果为 $0$：能，在 $8$ 位设备上，互为相反数的两个数相加的结果是 $1111\ 1111$，按照刚刚的定义它是 $-0$。
            \item 减去一个数，等于加上这个数的相反数：能，在 8 位设备上，加上一个数的相反数，等于加上 $1\ 0000\ 0000$ 减去这个数的差，由于“加上 $1\ 0000\ 0000$”在 8 位设备上等同于加 $0$，对结果无影响，因此加上一个数的相反数等于减去这个数；
            \item 表达结果直接相加减，等于相加减结果的表达：能，上一条可以将这一条合并成二进制的加法，而二进制的加法符合这一条要求；
            \item 不断“加 1”之后能走遍一个范围内的全部数，并且在溢出截断之后再次加“回”到某个数的时候，其所表达的数值不变：不符合，$1111\ 1111$ 加 1 之后的结果是 $0000\ 0000$，但其对应的十进制表达 $(-0) + 1 = 0$ 并不成立。
        \end{enumerate}

        最后一条期望，这种表达方式并不满足。但是，如果补充一个定义，“如果发生了溢出，则把溢出值移动到最低位再相加”，那么它便能符合期望：$1111\ 1111$ 加 1 之后的结果是 $1\ 0000\ 0000$，按照补充定义需要把 $1$ 移动到最右边与 $0000\ 0000$ 相加得到 $0000\ 0001$ 才得出最终结果，即 $(-0) + 1 = 1$ 的成立。

        事实上，这种表达方式在负数方面只与二补数相差了 1：二补数使用了 $2 ^ k$ 来减去对应的数，而这种表达方式使用了 $2 ^ k - 1$，因此这种表达方式表达的负数的二进制，等于这个数的二补数的二进制减去 1，于是这种表达方式被称为“一补数”（1's Complement）。

        从另一个方面也可以看出它命名为“一补数”的合理性：按照上面的定义，一个数与它的一补数相加，能得到一串 1，恰好能满足与二补数相仿的“补足”的内涵（某一位上相加的结果恰好为进位制基底），而这里的“补足”的基底看起来是“1”。

    \subsection[原码、反码与补码]{原码、反码与补码\footnote{这似乎是国内特有的概念。Geno 在进行了一定的探索后得出了这个结论，但暂时无法确定该结论是否正确。一补数、二补数的概念似乎只是反码、补码概念的子集：简体中文的文献经常提及“正数的反码、补码……，负数的反码、补码……”，但英文文献似乎仅提及“正数的相反数可以用二补数表示为……”，即简体中文文献将反码与补码视为一种独立的包含了正数、负数与 $0$ 的记数方式，而英文文献仅把补数视为依赖于正数与 $0$ 的一种非正数的记数方式。}}\label{subsec:NumberSystemBasics/BinaryPresentation/ChineseOnly}
        我们任意地指定三个概念，原码、反码与补码。

        原码指定，
        \begin{itemize}
            \item 最高位为符号位，并任意地指定 $0$ 表示正数，$1$ 表示负数；
            \item 剩下的位为数值位，记录准备表达的数的绝对值。
        \end{itemize}

        反码指定，当表达正数时，使用数的二进制表达；当表达负数时，使用一补数，即
        \begin{itemize}
            \item 最高位为符号位，$0$ 表示正数，$1$ 表示负数；
            \item 剩下的位为数值位，当表示正数时直接记录准备表达的数的二进制，当表示负数时记录准备表达的数的二进制的各位取反。
        \end{itemize}

        补码指定，当表达正数时，使用数的二进制表达；当表达负数时，使用二补数，即
        \begin{itemize}
            \item 最高位为符号位，$0$ 表示正数，$1$ 表示负数；
            \item 剩下的位为数值位，当表示正数时直接记录准备表达的数的二进制，当表示负数时记录准备表达的数的二进制的各位取反加 $1$ 的结果。
        \end{itemize}

        由于使用补码表达的二进制数，可以在包括正数、负数和 0 范围内的整数中直接进行正确的加减法，因此，虽然一补码在历史上曾经有过较为广泛的运用，但现代主流计算机中均使用以二补码为基础的补码作为整数的二进制记录方式。
