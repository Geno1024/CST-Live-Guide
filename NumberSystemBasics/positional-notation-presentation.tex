\section{进位制的表示}\label{sec:NumberSystemBasics/positional-notation-presentation}
    同一个数在不同的进位制中会有不同的表现形式，于是出现了不同进位制之间的表示与转换的问题。
    \subsection{记号表示}\label{subsec:NumberSystemBasics/positional-notation-presentation/natural}
        在数学上，记号通常由发明记号的数学家的想象力与其所学习的语言数量决定；而在计算机相关的方面，记号通常会受到输入输出的设备与系统的限制，因此数学和计算机（编程）方面的表示会有所不同。
        \begin{itemize}
            \item 数学上较为常见的记号是，将数直接写出，然后将底数作为下标附在其后。例如，二进制的 $1010$ 记为\[1010_2\]。有的记号则将数或基数使用小括号包裹，例如\[1010_{(2)}\]或\[(1010)_2\]，这些都是常见的数学上的进位制记号。
            \item 程序语言方面，在不同的场合与不同的程序语言中有不同的记号，并且大多数仅指定了记录十进制、十六进制和八进制的记号，少数指定了二进制的记号，少见可以指定任意进制的记号。最为常见的记号来自 C 语言，指定了十六进制前缀 \texttt{0x} 和八进制前缀 \texttt{0}，另外还有见于颜色表示的十六进制前缀 \texttt{\#}，见于 HTML 编码的 \texttt{x} 等。有时需要根据上下文才能判断具体的进制。
        \end{itemize}
    \subsection{二进制表示}\label{subsec:NumberSystemBasics/positional-notation-presentation/binary}
        由于现代计算机均采用二进制，因此需要找到一种可以只用二进制表示各种数，并且符合基本运算法则的方式。另外，由于存储空间的限制，我们需要考虑一个有限长度的记录方式，而非像数学那样理论上可以无限添加长度的记录方式（因此，这些记录方式通常存在一个能表达的数的范围，称为“数值范围”。关于数值范围，以及超出数值范围的数的表达，将在后续章节中再描述，此处暂时忽略）。

        为了讨论方便和章节简短，在本小节中，我们暂不讨论小数（同样，后续章节会介绍小数的记录方式），只考虑一个 $8$ 位的存储整数的设备（即，必须而且只能使用 $8$ 位二进制来表示，若超过 $8$ 位则将其截断，只保留最右边的 $8$ 位）。

        最容易想到的记录方式为，直接记录将源数字转换为二进制之后的结果，比如说将 $1$ 表达为 $0000\ 0001$，把 $2$ 表达为 $0000\ 0010$ 等，但是此种方式无法记录负数，因此创造了几种记录方式以便记录负数并令负数可计算。

        \subsubsection{补数}\label{subsubsec:NumberSystemBasics/positional-notation-presentation/binary/complement}
            对于一个 k 位 N 进制数 a，我们定义 a 的基补数（Radix Complement）为 $N ^ k - a$；定义 a 的减基补数（Diminished Radix Complement）为 $(N ^ k - 1) - a$。

            特别地，在我们当前讨论的上下文中，$k = 8$ 且 $N = 2$，则我们有：

            数 a 的二进制的二补数（2's Complement）为 $2 ^ 8 - a$，一补数（1's Complement）为 $(2 ^ 8 - 1) - a$。

            一个更加直观的计算方式是，对于一个正数的相反数，有：
            \begin{itemize}
                \item 一补数为该数二进制表达的各位取反（即，$1$ 变为 $0$，$0$ 变为 $1$）；
                \item 二补数为该数二进制表达的各位取反之后加 $1$ 的结果。
            \end{itemize}

            使用补数可以将减法变成加法，于是使用加法器既可以计算加法也可以计算减法，从而简化运算电路。例如，计算 $2 - 3$，可以转化为 $2 + (-3)$，然后使用一补数计算：
            \[0000\ 0010 + 1111\ 1100 = 1111\ 1110\]
            ，即可得到结果 $-1$；或者使用二补数计算：
            \[0000\ 0010 + 1111\ 1101 = 1111\ 1111\]
            ，也能得到正确结果 $-1$。

            注意，使用一补数计算时，如果发生了溢出，那么需要将溢出的值移动到最低位并相加，才能得到正确的结果。例如计算 $(-3) + (-5)$：
            \[1111\ 1100 + 1111\ 1010 = 1\ 1111\ 0110\]
            ，此时发生了溢出，按照定义，需要将溢出的 $1$ 再加回右边的 $1111\ 0110$ 上，得到 $1111\ 0111$，才能得到正确结果 $-8$。但二补数没有这个问题。

        \subsubsection[原码、反码与补码]{原码、反码与补码\footnote{这似乎是国内特有的概念。Geno 在进行了一定的探索后得出了这个结论，但暂时无法确定该结论是否正确。一补数、二补数的概念似乎只是反码、补码概念的子集：简体中文的文献经常提及“正数的反码、补码……，负数的反码、补码……”，但英文文献似乎仅提及“正数的相反数可以用二补数表示为……”，即简体中文文献将反码与补码视为一种独立的包含了正数、负数与 $0$ 的记数方式，而英文文献仅把补数视为依赖于正数与 $0$ 的一种非正数的记数方式。}}\label{subsubsec:NumberSystemBasics/positional-notation-presentation/binary/chinese-only}
            原码指定，
            \begin{itemize}
                \item 最高位为符号位，并任意地指定 $0$ 表示正数，$1$ 表示负数；
                \item 剩下的位为数值位，记录准备表达的数的绝对值。
            \end{itemize}

            反码指定，当表达正数时，使用数的二进制表达；当表达负数时，使用一补数，即
            \begin{itemize}
                \item 最高位为符号位，$0$ 表示正数，$1$ 表示负数；
                \item 剩下的位为数值位，当表示正数时直接记录准备表达的数的二进制，当表示负数时记录准备表达的数的二进制的各位取反。
            \end{itemize}

            补码指定，当表达正数时，使用数的二进制表达；当表达负数时，使用二补数，即
            \begin{itemize}
                \item 最高位为符号位，$0$ 表示正数，$1$ 表示负数；
                \item 剩下的位为数值位，当表示正数时直接记录准备表达的数的二进制，当表示负数时记录准备表达的数的二进制的各位取反加 $1$ 的结果。
            \end{itemize}

            由于使用补码表达的二进制数，可以在包括正数、负数和 0 范围内的整数中进行正确的加减法，因此现代计算机中均使用补码作为整数的记录方式。
