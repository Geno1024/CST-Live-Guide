\section{进位制的表示}\label{sec:ArithBasics/positional-notation-presentation}
    同一个数在不同的进位制中会有不同的表现形式，于是出现了不同进位制之间的表示与转换的问题。
    \subsection{记号表示}\label{subsec:ArithBasics/positional-notation-presentation/natural}
        在数学上，记号通常由发明记号的数学家的想象力与其所学习的语言数量决定；而在计算机相关的方面，记号通常会受到输入输出的设备与系统的限制，因此数学和计算机（编程）方面的表示会有所不同。
        \begin{itemize}
            \item 数学上较为常见的记号是，将数直接写出，然后将底数作为下标附在其后。例如，二进制的 $1010$ 记为\[1010_2\]。有的记号则将数或基数使用小括号包裹，例如\[1010_{(2)}\]或\[(1010)_2\]，这些都是常见的数学上的进位制记号。
            \item 程序语言方面，在不同的场合与不同的程序语言中有不同的记号，并且大多数仅指定了记录十进制、十六进制和八进制的记号，少数指定了二进制的记号，少见可以指定任意进制的记号。最为常见的记号来自 C 语言，指定了十六进制前缀 \texttt{0x} 和八进制前缀 \texttt{0}，另外还有见于颜色表示的十六进制前缀 \texttt{\#}，见于 HTML 编码的 \texttt{x} 等。有时需要根据上下文才能判断具体的进制。
        \end{itemize}
    \subsection{二进制表示}\label{subsec:ArithBasics/positional-notation-presentation/binary}
        由于现代计算机均采用二进制，因此需要找到一种可以只用二进制表示各种数，并且符合基本运算法则的方式。另外，由于存储空间的限制，我们需要考虑一个有限长度的记录方式，而非像数学那样理论上可以无限添加长度的记录方式（因此，这些记录方式通常存在一个能表达的数的范围，称为“数值范围”。关于数值范围，以及超出数值范围的数的表达，将在后续章节中再描述，此处暂时忽略）。

        为了讨论方便和章节简短，在本小节中，我们暂不讨论小数（同样，后续章节会介绍小数的记录方式），只考虑一个 $8$ 位的存储整数的设备（即，必须而且只能使用 $8$ 位二进制来表示，若超过 $8$ 位则将其截断，只保留最右边的 $8$ 位）。

        最容易想到的记录方式为，直接记录将源数字转换为二进制之后的结果，比如说将 $1$ 表达为 $0000\ 0001$，把 $2$ 表达为 $0000\ 0010$ 等，但是此种方式无法记录负数。为了顺利地记录负数，几种记录方式被制造了出来。

        \subsubsection{原码}\label{subsubsec:ArithBasics/positional-notation-presentation/binary/sign-magnitude}
            原码（Sign-Magnitude Form）指定，
            \begin{itemize}
                \item 最高位为符号位（Sign），并任意地指定 $0$ 表示正数，$1$ 表示负数；
                \item 剩下的位为数值位（Magnitude），记录准备表达的数的绝对值。
            \end{itemize}

            例如，$-1$ 记录为 $1000\ 0001$，$-2$ 记录为 $1000\ 0010$，$-127$ 记录为 $1111\ 1111$，等等。这个方式能够表达负数，但是轻易尝试将发现问题：
            \[1000\ 0001 + 0000\ 0001 = 1000\ 0010\]，
            这对应于十进制数将是，$(-1) + 1 = (-2)$，是非常荒唐的。因此需要继续寻找其他的记录方式。

        \subsubsection{一补码与反码}\label{subsubsec:ArithBasics/positional-notation-presentation/binary/one-complement}
            一补码（1's Complement）指定，对于一个正数的相反数，表达为该数二进制表达的各位取反（即，$1$ 变为 $0$，$0$ 变为 $1$）。

            反码指定，当表达正数时，使用数的二进制表达；当表达负数时，使用一补码，即
            \begin{itemize}
                \item 最高位为符号位，$0$ 表示正数，$1$ 表示负数；
                \item 剩下的位为数值位，当表示正数时直接记录准备表达的数的二进制，当表示负数时记录准备表达的数的二进制的各位取反。
            \end{itemize}

            例如，$-1$ 记录为 $1111\ 1110$，$-2$ 记录为 $1111\ 1101$，$-127$ 记录为 $1000\ 0000$，等等。这个方式能够表达负数，并且解决了相反数的和不为零的问题：
            \[0000\ 0001 + 1111\ 1110 = 1111\ 1111\]，
            结果 $1111\ 1111$ 初看起来不是 $0$，但是我们对照一下一补码的定义，就能发现其表达的是 $-0$。
            \begin{displayquote}
                $1111\ 1111$ 最高位为 $1$，表示负数，于是剩下的数值位全部取反，得到 $000\ 0000$，合起来即为 $-0$。
            \end{displayquote}
            但是，其依然存在问题：
            \[1111\ 1110 + 1111\ 1101 = 1111\ 1011\]，
            即 $(-1) + (-2) = (-4)$，另外上面我们也看到了 $0$ 存在两个表达（$+0$ 即 $0000\ 0000$，$-0$ 即 $1111\ 1111$）的问题，因此我们依然需要寻找其他的记录方式。

        \subsubsection{二补码与补码}\label{subsubsec:ArithBasics/positional-notation-presentation/binary/two-complement}
            二补码（2's Complement）指定，对于一个正数的相反数，表达为该数的二进制表达的各位取反之后加 $1$ 的结果。

            补码指定，当表达正数时，使用数的二进制表达；当表达负数时，使用二补码，即
            \begin{itemize}
                \item 最高位为符号位，$0$ 表示正数，$1$ 表示负数；
                \item 剩下的位为数值位，当表示正数时直接记录准备表达的数的二进制，当表示负数时记录准备表达的数的二进制的各位取反加 $1$ 的结果。
            \end{itemize}

            例如，$-1$ 记录为 $1111\ 1111$，$-2$ 记录为 $1111\ 1110$，$-127$ 记录为 $1000\ 0001$，等等。这个方式能够解决上面两种方式所存在的问题：

            相反数相加可以得到 $0$，例如 $-1 + 1 = 0$ 可以表达为：
            \[1111\ 1111 + 0000\ 0001 = 0000\ 0000\]

            负数相加的结果也符合期望，例如 $-1 + -2 = -3$ 可以表达为：
            \[1111\ 1111 + 1111\ 1110 = 1111\ 1101\]

            如上，由于使用补码表达的二进制数，可以在包括正数、负数和 0 范围内的整数中进行正确的加减法，因此现代计算机中均使用补码作为整数的记录方式。
